# Java基础

## 面向对象与面向过程的区别

### 面向过程：

- **优点：**性能比面向对象高，因为面向对象中类调用时需要实例化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux\Unix等一般采用面向过程开发，性能是最重要的因素。
- **缺点：**没有面向对象易维护、易复用、易扩展。

### 面向对象：

- **优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
- **缺点：**性能比面向过程低。

## Java与C++的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理机制，不需要程序员手动释放无用内存

## 什么是OO,OOA,OOD,OOP？

> 参考：[https://www.jianshu.com/p/41b3d7e1c624](https://www.jianshu.com/p/41b3d7e1c624)

- OO :**Object - Oriented** ,面向对象,基于对象概念,以对象为中心,以类和继承为构造机制,来认识,理解,刻画客观世界和设计,构建相应的软件系统的一门方法;本意-- 模拟人类的思维方式,使开发,维护,修改更加容易。
- OOA:**Object - Oriented Analysis**, 面向对象分析,强调的是在系统调查资料的基础上,针对OO方法所需要的素材进行的归类分析和整理,而不是对管理业务现状和方法的分析---其实就是进一步对OO进行细化,初步得出OO的方法(或者简单的理解:在得出的文档中对接口粗略定义)。
- OOD:**Object - Oriented Design**,面向对象设计,OO方法中一个中间过渡环节,其主要作用是对OOA分析的结果进一步的规范和整理,以便能够被OOP直接接受---整理和定义OO的属性和方法。
- OOP:**Object - Oriented Programming**,把组件的实现和接口分开,并且让组件具有多态性---(抽象,封装,继承,多态)面向接口编程。

## 8种基本数据类型

| 序号 |    数据类型     | 位数 | 默认值 |    取值范围    |       举例        |
| :--: | :-------------: | :--: | :----: | :------------: | :---------------: |
|  1   |    byte(字节)     |  8   |   0    |  -2^7 - 2^7-1  |   byte b = 10;    |
|  2   |  short(短整数)  |  16  |   0    | -2^15 - 2^15-1 |   short s = 10;   |
|  3   |    int(整数)    |  32  |   0    | -2^31 - 2^31-1 |    int i = 10;    |
|  4   |  long(长整数)   |  64  |   0    | -2^63 - 2^63-1 |   long l = 10l;   |
|  5   |  float(单精度)  |  32  |  0.0   | -2^31 - 2^31-1 | float f = 10.0f;  |
|  6   | double(双精度)  |  64  |  0.0   | -2^63 - 2^63-1 | double d = 10.0d; |
|  7   |   char(字符)    |  16  |   空   |   0 - 2^16-1   |   char c = 'c';   |
|  8   | boolean(布尔值) |  8   | false  |  true、false   | boolean b = true; |

## 抽象和封装、继承、多态

> 封装、继承、多态称为Java面向对象的三大特性。封装主要是隐藏内部代码；继承主要是复用现有代码；多态主要是改写对象行为。

### 抽象和封装

- 类的抽象：将类的实现和类的使用分开。

- 类的封装：实现的细节被封装并且对用户隐藏。

类的创建者描述类的功能，让使用者明白如何才能使用类。从类外可以访问的方法和数据域的集合以及预期这些成员如何行为的描述。类的使用者不需要知道类是如何实现的。

### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

1. 子类拥有父类非 private 的属性（数据域）和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法（重写）。
4. 子类不可以重写父类的构造方法。

### 多态 

> 多态意味着父类的变量可以指向子类对象。
>

#### 实现方式

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

#### 动态绑定

一个方法可以在继承链的几个类中被实现。JVM决定在运行时调用哪个方法。

## 抽象类和接口

> 参考：[https://www.cnblogs.com/dolphin0520/p/3811437.html](https://www.cnblogs.com/dolphin0520/p/3811437.html)（评论很精彩，别错过）

### 抽象类

- 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法）。
- 抽象类不能用来创建对象；
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

　　在其他方面，抽象类和普通的类并没有区别。

### 接口

- 接口中可以含有 变量和方法。

- 接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）。

- 接口中的方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）。

- 接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法（Java8中接口有static和default方法可以有默认实现）。

  > 在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。
  > 如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，不然会报错

## 自动装箱与拆箱

### 装箱

> 将基本类型值转换为包装类对象的过程称为装箱（boxing）；

### 拆箱

> 装箱的相反转换过程，将包装类对象转换为基本数据类型的过程称为装箱（unboxing）；

Java允许基本类型和包装类类型之间进行**自动转换**。

## 方法重写和重载

### 方法重写

是指子类从父类中继承方法。使用场景一般是子类需要修改父类中定义的方法的实现。

- 仅当实例方法是可访问的，才能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系。
- 重写的方法必须使用相同的签名和相同的返回值类型在子类中定义。
- 静态方法也**能被继承但不能被覆盖**。

### 方法重载

重载方法使得你可以使用相同的名字来定义不同的方法，只要它们的签名是不同的。也就是说，一个类中有多个方法，具有相同的名字，但有不同的参数列表。Java编译器根据方法签名决定使用哪个方法。

### 重写和重载的区别

- 方法重写放生在通过继承而相关的不同类中；方法重载可以发生在同一个类中，也可以发生在由于继承而相关的不同类中。
- 方法重写具有相同的签名和返回值类型；方法重载具有相同的名字，但是不同的参数列表。

## 对象转换

> 对象的引用可以类型转换为对另一种对象的引用，这称为对象转换。

- 将对象`new Student()`赋值给一个`Object`类型的参数：

```java
Object o = new Student();
```

由于Student的实例也是Object的实例，所以语句`Object o = new Student();`合法。称为**隐式转换（implicit casting）**。像这样，将一个子类的实例转换成一个父类的变量，称为**向上转换（upcasting）**。

- 将`Object`类型的对象赋值给一个`Student`类型的参数：

```java
Student s = (Student)o;
```

为了告诉编译器o是一个Student对象，就要使用**显示转换（explicit casting）**。像这样，把一个父类的实例转换为它的子类变量，称为**向下转换（downcasting）**。

## equals方法与"=="运算符

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
- 类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

*注：*equals方法是被定义在Object类中的，但在Java API的许多类中被重写，比如我们常用的`java.lang.String`和`java.util.Date`，用于比较两个对象的内容是否相等。Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

**警告：**在子类中，应该使用`equals(Object obj)`签名来重写equals方法，而不是形如`equals(SomeClassName obj)`来重写。

**==** : 比较两个基本数据类型的值是否相等，或者判断两个对象是否具有相同的引用（判断两个对象的地址是不是相等），也就是说，基本数据类型==比较的是值，引用数据类型==比较的是内存地址。

## 可见性修饰符

> 修饰符private、protected和public都称为可见性修饰符(visibility modifier)或可访问性修饰符(accessibility modifier)。用来指定是否可以从类外部访问数据域和方法。
>
> 局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；

### 类中成员的修饰符

| 类中成员的修饰符 | 在同一类可访问 | 在同一包内可访问 | 在子类内可访问 | 在不同包可访问 |
| :--------------: | :------------: | :--------------: | :------------: | :------------: |
|      public      |       √        |        √         |       √        |       √        |
|    protected     |       √        |        √         |       √        |       —        |
|    (default)     |       √        |        √         |       —        |       —        |
|     private      |       √        |        —         |       —        |       —        |

private：完全隐藏类的成员，不能从类外直接访问；

(default)：允许同一个包内的任何类直接访问类的成员，但是其它包中的类不可以访问；

protected：允许任何包中的子类或同一包中的类访问类的成员；

public：允许任意类访问类的成员。

### 类修饰符

修饰符private和protected只能用于类中的成员。public修饰符和(default)修饰符（也就是没有修饰符）既可以用于类的成员，也可以用于类。也就是说**一个类要么没有修饰符要么就是用public修饰**，但是**一个没有修饰符的类不能被其它包中的类访问**。

**注意**：子类可以重写它的父类中被protected修饰的方法，并把它的可见性改为public。但是**子类不能削弱父类中定义的方法的可访问性**，例如，如果一个方法在父类中定义为public，在子类中也必须定义为public。

