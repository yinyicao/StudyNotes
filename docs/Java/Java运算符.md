# Java运算符

## 位运算符

**Java在进行位运算时，byte类型将自动转换为int类型进行计算，byte型转换为补码后，对于不够的位数（byte类型8位，int类型32位），正数在前面添0，负数在前面添1。如果强制转换为byte类型输出将取int类型后8位输出**

在此之前，还应该知道这些：

1. 计算机中都是以**补码**形式进行数值计算，所以我们接下来的每次运算都应该转换为**补码**。
2. 正数的原码、反码、补码相同，负数(符号位为1)的反码为原码除符号位（第一位为符号位）以外，其它位取反，负数的补码为反码+1。
3. 将补码转为原码：正数的原码、反码、补码相同，负数(符号位为1)要将补码-1得到反码，再将反码（除符号位外）按位取反得到原码。

下表列出了位运算符的基本运算：

| 操作符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| &      | 按位与，如果（补码）相对应位都是1，则结果为1，否则为0。      |
| \|     | 按位或，如果（补码）相对应位都是0，则结果为0，否则为1。      |
| ^      | 按位异或，如果（补码）相对应位值相同，则结果为0，否则为1。   |
| ~      | 按位取反，翻转操作数（补码）的每一位，即0变成1，1变成0。     |
| <<     | 按位左移，左操作数（补码）按位左移右操作数指定的位数。       |
| \>>    | 按位右移，左操作数（补码）按位右移右操作数指定的位数。       |
| \>>>   | 无符号按位右移。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |

### 按位与运算符(&)

> 按位与，如果相对应位（补码）都是1，则结果为1，否则为0。

正数&正数：(正数的原码、反码、补码一致)

3的补码为：0000 0011，7的补码为：0000 0111，按位与操作后为：0000 0011，转为十进制为：3。

正数&负数：

-3的二进制（原码）为：1000 0011，补码为：1111 1101，7的补码为：0000 0111，按位与操作后为：0000 0101，符号位为0，是正数，直接转为十进制为：5。

负数&负数：

-3的补码为：1111 1101，-7的补码为：1111 1001，按位与操作后为：1111 1001，符号位为1，是负数，转为反码为：1111 1000，原码为：1000 0111，转为十进制为：-7。

```java
byte num1=3;
byte num2=7;
byte num3=-3;
byte num4=-7;
System.out.println( num1 & num2 ); /*(byte类型将自动转换为int类型进行计算) 3 */
System.out.println( num3 & num2 );/*(byte类型将自动转换为int类型进行计算) 5 */
System.out.println( num3 & num4 );/*(byte类型将自动转换为int类型进行计算) -7 */
```

**运用：** 可以巧妙地使用按位与运算符进行奇偶数(正负数都可以)判断：`偶数 & 1 == 0，奇数 & 1 == 1` 

### 按位或运算符(|)

> 按位或，如果（补码）相对应位都是0，则结果为0，否则为1。

正数|正数：(正数的原码、反码、补码一致)

3的补码为：0000 0011，7的补码为：0000 0111，按位或操作后为：0000 0111，符号位为0，是正数，直接转为十进制为：7。

正数|负数：

-3的二进制（原码）为：1000 0011，补码为：1111 1101，7的补码为：0000 0111，按位或操作后为：1111 1111，符号位为1，是负数，将1111 1111（补码）转为原码为：1000 0001，转为十进制为：-1。

负数|负数：

-3的补码为：1111 1101，-7的补码为：1111 1001，按位或操作后为：1111 1101，符号位为1，是负数，转为原码为：1000 0011，转为十进制为：-3。

```java
byte num1=3;
byte num2=7;
byte num3=-3;
byte num4=-7;
System.out.println( num1 | num2 ); /*(byte类型将自动转换为int类型进行计算) 7 */
System.out.println( num3 | num2 );/*(byte类型将自动转换为int类型进行计算) -1 */
System.out.println( num3 | num4 );/*(byte类型将自动转换为int类型进行计算) -3 */
```

### 按位异或运算符(^)

> 按位异或，如果（补码）相对应位值相同，则结果为0，否则为1。

正数^正数：(正数的原码、反码、补码一致)

3的补码为：0000 0011，7的补码为：0000 0111，按位异或操作后为：0000 0100，符号位为0，是正数，直接转为十进制为：4。

正数^负数：

-3的二进制（原码）为：1000 0011，补码为：1111 1101，7的补码为：0000 0111，按位异或操作后为：1111 1010，符号位为1，是负数，将1111 1010（补码）转为原码为：1000 0110，转为十进制为：-6。

负数^负数：

-3的补码为：1111 1101，-7的补码为：1111 1001，按位异或操作后为：0000 0100，符号位为0，是正数，转为十进制为：4。

```java
byte num1=3;
byte num2=7;
byte num3=-3;
byte num4=-7;
System.out.println( num1 ^ num2 ); /*(byte类型将自动转换为int类型进行计算) 4 */
System.out.println( num3 ^ num2 );/*(byte类型将自动转换为int类型进行计算) -6 */
System.out.println( num3 ^ num4 );/*(byte类型将自动转换为int类型进行计算) 4 */
```

### 按位非运算符(~)

> 按位取反运算，翻转操作数（补码）的每一位，即0变成1，1变成0。

正数：

6的补码为：0000 0000 0000 0000 0000 0000 0000 0110 ，按位非后得到：1111 1111 1111 1111 1111 1111 1111 1001

因为符号位为1，表示负数，将这串二进制当作补码转换为反码：1111 1111 1111 1111 1111 1111 1111  1000，再将反码转为原码：1000 0000 0000 0000 0000 0000 0000 0111，最后转为十进制输出：-7。

负数：

-6的原码为：1000 0000 0000 0000 0000 0000 0000 0110，反码：1111 1111 1111 1111 1111 1111 1111 1001，补码：1111 1111 1111 1111 1111 1111 1111 1010，按位非后得到：0000 0000 0000 0000 0000 0000 0000 0101

再将这串二进制当作补码，由于符号位为0（正数）,所以原码和补码一致，最后转为十进制输出：5。

```java
int num1 = 6;
int num2 = -6;
System.out.println("~num1："+ ~num1 );  /* ~num1：-7*/
System.out.println( "~num2："+ ~num2 ); /* ~num2：5*/
```

### 按位左移运算符(<<)

> 按位左移，左操作数（补码）按位左移右操作数指定的位数。

正数：

5<<3

5的补码为：0101 ，左移三位末尾补0，得到：0010 1000，符号位为0，转为十进制得：40。

负数：

-5<<3

-5的补码为：1111 1111 1111 1111 1111 1111 1111 1011，左移三位末尾补0，得到1111 1111 1111 1111 1111 1111 1111 1101 1000，因为符号位为1，代表负数，在将其（补码）转换为原码为：1000  0000 0000 0000 0000 0000 0010 1000，得到十进制数为：-40。

-21<<3

-21的补码为：1111 1111 1111 1111 1111 1111 1110 1011，左移三位末尾补0，得到：1111 1111 1111 1111 1111 0101 1000，因为符号位为1，代表负数，在将其（补码）转换为原码为：1000 0000 0000 0000 0000 0000 1010 1000，得到十进制数为：-168。

### 按位右移运算符(>>)

> 按位右移，左操作数（补码）按位右移右操作数指定的位数。左边的用原有标志位补充，右边超出的部分舍弃。

正数：25>>3

25的补码为：0001 1001，右移三位左边补0：0000 0011，转为十进制为：3。

负数：-25>>3

-25的补码为： 1111 1111 1111 1111 1111 1111 1110 0110 ，右移3位左边补1： 1111 1111 1111 1111 1111 1111 1111 1100，转换为原码：1000 0000 0000 0000 0000 0000 0000 0100，得：-4。

### 无符号按位右移运算符(>>>)

> 按位右移补零操作符。左操作数的值(补码按右操作数指定的位数右移，无论是正数还是负数移动得到的空位以零填充。

正数：21>>>3

21的补码为:0001 0101，右移3位并在左边补零：0000 0010，得：2。

负数：-21>>>3

-21的补码为：‭1111 1111 1111 1111 1111 1111 1110 1**011**，右移3位并在左边补零：  0001  1111 1111 1111 1111 1111 1111 1101‬，符号位为0，正数，原码和补码一致，所以化为十进制得：536870909。

```java
System.out.println(21 >>> 3);/* 2 */
System.out.println(-21 >>> 3);/* 536870909 */
```

